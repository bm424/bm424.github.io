<!doctype html>
<html lang="en">
<head>
    <title>bm424</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&family=Raleway&display=swap"
          rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
    <link href="highlight-styles.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<main>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2022-12-19-functional_graph_algorithms_1" href="#2022-12-19-functional_graph_algorithms_1">Implementing Functional Graph Algorithms in Python (Part 1: Data Types)</a>
          </span>
                
                    <span class="line"><small>2022-12-19</small></span>
                
            </h1>
            <p><em>This article was originally published on
Medium (<a href="https://medium.com/@benhmartineau/implementing-functional-graph-algorithms-in-python-part-1-data-types-b9ef1e3742e5">link</a>)</em></p>
<p>If you've ever read articles about functional programming in Python, you probably already know about <code>map</code>, <code>filter</code>, and
<code>reduce</code>, which are useful functions for functional programming using lists. However, if you're like me, you may have
sometimes felt that articles like that are a bit shallow, and don't really teach you anything about how to use Python as
a functional programming language in general. I'd like to show you a more challenging functional programming problem,
and demonstrate that Python has a great syntax for writing elegant, concise functional code.</p>
<p>This will be a four-part series. In this part, I'll be describing the problem of functional graph algorithms, and
setting up basic data structures. In Part 2, I'll implement the basic functions we'll need to write more expressive
algorithms, which we'll cover in Part 3. Finally, I'll give you my final thoughts on this exercise (a "retro", if you
like) in Part 4.</p>
<p>You can find all of the code for these articles at
the <a href="https://github.com/bm424/inductive-graph-algorithms"><code>inductive-graph-algorithms</code></a> repository over on GitHub.</p>
<h1>The Problem</h1>
<p>Many programmers will have had to do some work with data structures like trees, such as JSON data or web documents, or
graphs, such as are used in data processing frameworks like Airflow. A few months ago, I was working on designing a
system with a graph-like structure. I'm a big fan of functional programming, so I started wondering: how does a
functional program implement algorithms like <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a>?</p>
<p>In the world of imperative programming, topological sorting is not very difficult — Kahn's algorithm and a depth-first
search algorithms are both described on the Wikipedia page linked above. However, both rely on stateful mutations of the
graph's nodes, because they need us to keep track of visited nodes via a label. Stateful changes should not be part of
our functional implementation.</p>
<h1>The Solution</h1>
<p>After a little bit of googling, I came
across <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/inductive-graphs-and-functional-graph-algorithms/2210F7C31A34EA4CF5008ED9E7B4EF62">this paper</a> 
(Erwig 2001), which describes the principle of "inductive"
graphs, and forms the basis of Haskell's functional graph library <code>fgl</code>. I'll try to quickly explain inductive graphs by
analogy to a list, but for a more detailed explanation see
this <a href="https://math.stackexchange.com/a/1224804">StackExchange answer</a> and its linked blog post — they're
both excellent.</p>
<p>When we take a sequence like a list or a tuple, and remove an item, we produce a pair: the item, and a new list or tuple
with all the existing items except for the one we just removed. We can then repeat the operation on the new list.
Functions like <code>map</code>, <code>filter</code>, and <code>reduce</code> can be concisely defined because of this repetition.</p>
<p><img alt="A diagram with four parts, representing generalised functional operations on sequences. In part 1, a series of 5 circles
are joined together with lines, representing a list. In part 2, the first circle is separated and highlighted,
representing its removal and usage in some functional operation. Part 3 shows the 4 remaining circles, and part 4 shows
the removal of the first circle as in part 2." src="functions_over_lists.png" /></p>
<p><em>Basic operation for functions over lists: 1) Start with a list of any length. 2) Remove the first item and perform some
operation. 3) You now have a smaller list. 4) Repeat from step 2.</em></p>
<p>An inductive graph has a similar property. Instead of removing a single item, we remove a node and all of its connected
edges, returning a graph without any reference to the node we just removed. We can then repeat the operation on the new
graph. This means we can define functions analogous to <code>map</code>, <code>filter</code>, and <code>reduce</code> for an inductive graph, and go
further,
implementing depth-first walks, shortest-path algorithms, and, indeed, topological sorts.</p>
<p><img alt="A diagram with four parts, representing generalised functional operations on graphs. In part 1, a series of 5 circles
are joined together with lines, representing a graph. In part 2, an arbitrary circle is separated and highlighted,
representing its removal and usage in some functional operation. Part 3 shows the 4 remaining circles, and part 4 shows
the removal of another arbitrary circle as in part 2." src="functions_over_graphs.png" /></p>
<p><em>Basic operation for inductive functions over graphs: 1) Start with any graph. 2) Remove a node and all of its edges and
perform some operation. 3) You now have a smaller graph. 4) Repeat from step 2.</em></p>
<h1>Implementation</h1>
<h2>Notes</h2>
<p>The paper describes its data structures and functions in Haskell syntax, so we need to work out how to convert this into
Python. I've generally adopted the following approach:</p>
<ol>
<li>Types and data types are implemented as classes, and where the types need to be destructured I've
   implemented <code>__iter__</code>
   so that we can use Python's destructuring (for example <code>x, *y = […]</code>) to closely match the definition.</li>
<li>I've implemented most of the functions as methods on the classes, rather than external functions, because it keeps
   the
   code organised and "more Pythonic".</li>
<li>"Queues" are ordered sequences — I've used tuples rather than lists to prevent accidental mutation. In some
   algorithms,
   the order doesn't matter and for these cases I've used the builtin <code>frozenset</code>, rather than plain <code>set</code>s, again to
   avoid
   accidental mutation.</li>
<li>Later in the paper, a "heap" is used for shortest-path algorithms. Python has built-in efficient heap algorithms in
   the
   <code>heapq</code> package, but these rely on mutating lists in-place. I implemented a wrapper class which helps ensure
   immutability.</li>
</ol>
<h2>Node</h2>
<p>The very first type described in the paper is the type</p>
<pre class="codehilite"><code class="language-hs">type Node = Int
</code></pre>

<p>That's right, nodes are integers. Actually, we can think of this as being like the index of an item in the list — the
node type is the "index" of the node in the graph. In Python:</p>
<pre class="codehilite"><code class="language-python">class Node(int):
    &quot;&quot;&quot;A node.

    For convenience, nodes are represented by integers.
    &quot;&quot;&quot;
</code></pre>

<p>Simple!</p>
<h2>"Adj"</h2>
<pre class="codehilite"><code class="language-hs">type Adj b = [(b, Node)]
</code></pre>

<p>This is a bit more abstract. It means that <code>Adj</code> is a sequence of tuples. Each tuple represents an edge in the graph,
and
<code>b</code> represents the edge's label, which can be anything, so we leave it generic. Note that edges are directed: <code>Adj</code> may
describe a connection to or from a given node, but by itself it doesn't care which.</p>
<pre class="codehilite"><code class="language-python">class Adj(collections.abc.Sequence[tuple[B, Node]]):
    &quot;&quot;&quot;Adjacency relationships.&quot;&quot;&quot;

    labeled_nodes: tuple[tuple[B, Node], ...]

    def __init__(self, labeled_nodes: tuple[tuple[B, Node], ...] = ()):
        self.labeled_nodes = labeled_nodes

    def __repr__(self):
        return f&quot;Adj({self.labeled_nodes!r})&quot;

    def __len__(self):
        return len(self.labeled_nodes)

    def __getitem__(self, item):
        return self.labeled_nodes[item]

    def __eq__(self, other):
        return self.labeled_nodes == other.labeled_nodes

    def __add__(self, other):
        return Adj(self.labeled_nodes + other.labeled_nodes)
</code></pre>

<p>I've made this class inherit from the Sequence class, which means if we implement <code>__len__</code> and <code>__getitem__</code> we get
iteration for free. I've also specified <code>__eq__</code> and <code>__add__</code> so that the class behaves like a tuple.</p>
<pre class="codehilite"><code class="language-hs">Context
type Context a b = (Adj b, Node, a, Adj b)
</code></pre>

<p>More abstract again! This says that a "context" comprises four parts: an adjacency relationship, a node, the label of
that node (<code>a</code>), and another adjacency relationship. The first <code>Adj</code> represents edges directed towards <code>Node</code>, called
"predecessors", and the second <code>Adj</code> represents edges directed away from <code>Node</code>, called "successors". It's important to
note
that, for inductive graphs, this doesn't have to be all of the connected nodes, because other <code>Context</code>s may define
additional <code>Adj</code> relationships.</p>
<p>There are two generic types here: <code>a</code> is the type of the node's label, and <code>b</code> is the type of the edge's label.</p>
<p><img alt="A diagram showing the &quot;context&quot; of a node in an inductive graph. There are four circles, of which one is central and
highlighted. It has a highlighted arrow, labelled &quot;predecessor&quot;, directed towards it from one of the other circles.
Another highlighted arrow, labelled &quot;successor&quot; is directed out of it toward one of the other circles. Another arrow,
not highlighted, points towards the last circle, and is labelled &quot;Another node's ‘Adj'&quot;." src="context_in_inductive_graph.png" /></p>
<p><em>Anatomy of a "Context": predecessor edges pointing to this node, successor edges pointing away from this node, and a
label of arbitrary type on the node itself. Note that a "Context" doesn't necessarily refer to all of the edges
connecting into a node, because these might be parts of other "Context"s.</em></p>
<pre class="codehilite"><code class="language-python">class Context(typing.Generic[A, B]):
    &quot;&quot;&quot;A context.

    A node's context describes (some of) its surroundings, including its label, its 
    adjacent predecessors and its adjacent successors.
    &quot;&quot;&quot;

    predecessors: Adj[B]
    node: Node
    label: A
    successors: Adj[B]

    def __init__(
            self,
            predecessors: Adj[B],
            node: Node,
            label: A,
            successors: Adj[B],
    ):
        self.predecessors = predecessors
        self.node = node
        self.label = label
        self.successors = successors

    def __repr__(self):
        return f&quot;Context({self.predecessors!r}, {self.node!r}, {self.label!r}, {self.successors!r})&quot;

    def __eq__(self, other):
        return (
                self.predecessors == other.predecessors
                and self.node == other.node
                and self.label == other.label
                and self.successors == other.successors
        )
</code></pre>

<h2>Graph</h2>
<p>Finally, we can describe a graph itself:</p>
<pre class="codehilite"><code class="language-hs">data Graph a b = Empty | Context a b &amp; Graph a b
</code></pre>

<p>This says that a graph is either an empty graph OR a context attached (using the operator <code>&amp;</code>) to a graph.</p>
<p>Python doesn't have variant types like this, but we can use inheritance instead. We'll define an abstract <code>Graph</code> class
that will have two subclasses: <code>EmptyGraph</code> and <code>InductiveGraph</code>.</p>
<pre class="codehilite"><code class="language-python">class Graph(abc.ABC, typing.Generic[A, B]):
    &quot;&quot;&quot;An abstract graph&quot;&quot;&quot; 
</code></pre>

<p>The <code>InductiveGraph</code> will contain a "head", which is the Context a b, and a "tail", which is another graph.</p>
<pre class="codehilite"><code class="language-python">class EmptyGraph(Graph[A, B]):
    &quot;&quot;&quot;An empty graph, containing no nodes or edges.&quot;&quot;&quot;

    def __repr__(self):
        return &quot;EmptyGraph&quot;
</code></pre>

<pre class="codehilite"><code class="language-python">class InductiveGraph(Graph[A, B]):
    &quot;&quot;&quot;An inductive graph.

    The `head` of the graph is a context that can only refer to nodes in the `tail`,
    which is also a graph.
    &quot;&quot;&quot;

    head: Context[A, B]
    tail: Graph[A, B]

    def __init__(self, head: Context[A, B], tail: Graph[A, B]):
        self.head = head
        self.tail = tail

    def __repr__(self):
        return f&quot;{self.head!r} &amp; {self.tail!r}&quot;
</code></pre>

<h2>Construction</h2>
<p>As well as the data itself, we can implement the constructor operator <code>&amp;</code> using Python! In the paper, we imagine
building
up graphs right-to-left, starting with the empty graph, and adding on context until we reach the whole graph:</p>
<pre class="codehilite"><code class="language-python">Context(...) &amp; Context(...) &amp; Context(...) &amp; EmptyGraph()
</code></pre>

<p><img alt="A diagram illustrating the construction of inductive graphs using the &quot;&amp;&quot; operator. At the top, a collection of circles,
some of which have lines attached, are aligned with the &quot;&amp;&quot; operator separating them. On the right hand side is a circle
with a line through it representing the empty graph. At the bottom is an &quot;equals&quot; sign followed by a complete graph
formed of the parts above." src="constructing_inductive_graph.png" /></p>
<p><em>Principle for constructing an inductive graph: start with the empty graph (right hand side). Then, attach the first
context — the "Adj" values must be empty, because there are no nodes! Then, attach contexts one by one; each can only
refer to nodes that are already in the graph.</em></p>
<p>Each context must only refer to nodes which are already in the graph (or, to make loops work, itself).</p>
<p>In Python, operators resolve left-to-right, so to emulate this behaviour I've introduced a _<code>ContextPartial</code> class which
can collect up left-hand-side contexts until it reaches a graph, at which point it resolves. As a result, we can define
the <code>__and__</code> operator on the <code>Context</code> class like so:</p>
<pre class="codehilite"><code class="language-python">class Context(typing.Generic[A, B]):
    def __and__(self, other):
        match other:
            case Context():
                return _ContextPartial((other, self))
            case InductiveGraph() if self.node in other.nodes():
                raise NodeExistsError(
                    f&quot;context {self} refers to existing node {self.node} in graph {other}&quot;
                )
            case InductiveGraph() if disjoint_nodes := tuple(
                    node
                    for node in self.pre + self.suc
                    if node not in other.nodes() and node != self.node
            ):
                raise NodeDoesNotExistError(
                    f&quot;context {self} &quot;
                    f&quot;refers to adjacent nodes {disjoint_nodes} &quot;
                    f&quot;which are not in graph {other}&quot;
                )
            case InductiveGraph() | EmptyGraph():
                return InductiveGraph(self, other)
</code></pre>

<p>This describes the behaviour when we do something like:</p>
<pre class="codehilite"><code class="language-python">context_a &amp; context_b &amp; EmptyGraph()
</code></pre>

<p>When the context is added to an inductive graph where the node is already in the graph, or if the context's <code>Adj</code> nodes
refer to nodes that are <em>not</em> in the graph, we have to raise an error. Otherwise, regardless of whether it is an
inductive
graph or an empty graph, we can construct a new graph with the context as the head.</p>
<p>There are a couple of methods and properties here — <code>.nodes()</code>, <code>.pre</code>, <code>.suc</code> — which we haven't seen yet. More on
those in
the next part!</p>
<h1>Usage</h1>
<p>After these definitions, we're ready to follow the first example in the paper, Figure 1, which constructs a graph using
edges labeled "left", "right", "up", and "down", and nodes labeled "a", "b", and "c".</p>
<pre class="codehilite"><code class="language-hs">([(&quot;left&quot;, 2), (&quot;up&quot;, 3)], 1, &quot;a&quot;, [(&quot;right&quot;, 2)]) &amp;
([], 2, &quot;b&quot;, [(&quot;down&quot;, 3)]) &amp;
([], 3, &quot;c&quot;, []) &amp;
Empty
</code></pre>

<p>becomes in Python:</p>
<pre class="codehilite"><code class="language-python">graph: InductiveGraph[str, str] = (
        Context(
            Adj(((&quot;left&quot;, Node(2)), (&quot;up&quot;, Node(3)))),
            Node(1),
            &quot;a&quot;,
            Adj(((&quot;right&quot;, Node(2)),)),
        )
        &amp; Context(Adj(), Node(2), &quot;b&quot;, Adj(((&quot;down&quot;, Node(3)),)))
        &amp; Context(Adj(), Node(3), &quot;c&quot;, Adj())
        &amp; EmptyGraph()
)
</code></pre>

<p><img alt="A diagram reproducing the example in Erwig 2001, showing a directed graph with three nodes connected by four edges." src="example_graph.png" /></p>
<p><em>The node "a", with two predecessors and one successor, is attached to "b", with one successor, and then attached to "c",
with no predecessors or successors, and finally the empty graph.</em></p>
<h1>Next up</h1>
<p>In the next article, we'll work into the next parts of the paper, which describes the properties needed from the
inductive graph data types, and implement them in Python, and use them to implement some simple graph algorithms. Then,
in the final section, we'll tackle some more difficult algorithms like topological sorting. Thanks for keeping up with
me so far!</p>
<h1>References</h1>
<p>Erwig, Martin. "Inductive graphs and functional graph algorithms." Journal of Functional Programming 11.5 (2001):
467–492.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-07-09-build_day_5" href="#2021-07-09-build_day_5">Build Day 5</a>
          </span>
                
                    <span class="line"><small>2021-07-09</small></span>
                
            </h1>
            <p>So; after deciding that the full dinosaur family tree might be a little too ambitious for a showcase React project, I've brought myself back down to earth with something still challenging but manageable, and it's something I've wanted to tackle for a little while: an itenerary planner.</p>
<p>Here's the basic idea: when I go for a long trip, especially one overseas or involving multiple stops, I normally start to piece things together in a spreadsheet detailing the start, end, type of journey being made, and so on at each stage of the trip.
Often there are files or links associated with each stage that I'd also like to link, like PDFs of train tickets, Visas, or whatever.
However, there's often a lot of manual shuffling and rewriting for this kind of work - say I want to introduce an intermediate stop or two and I have to rearrange the origin and destination of the surrounding stops.
That's a pain and adds an element of tedium to the planning process.
It'd be nice to have a little app that did all that for me, without going into the complexities of apps like AirBnB or DesignMyNight or whatever that have a lot of connections going in (and out).
I just want to plan my trip, my way.</p>
<p>Now, in all honesty, it's unlikely that I can put something together here that will actually become <em>the</em> itinerary planner going forward.
There's a lot to be said for the flexibility of, say, a spreadsheet (or, it occurs to me, a Notion doc).
However, there are some really nice interactive components we can build here and as a project it's a pretty solid one, that I'm guessing visitors (hey, you!) can relate to, even if it's not something you (or I) are actually likely to use.</p>
<p>I'll probably next write when I've got a working prototype, because for now the whole thing is very much in the set-up phase.
Until then.</p>
<p>Note to self: build a table of contents for this page as well.
Perhaps even some smooth scrolling, idk.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-07-08-build_day_4" href="#2021-07-08-build_day_4">Build Day 4</a>
          </span>
                
                    <span class="line"><small>2021-07-08</small></span>
                
            </h1>
            <p>So; a couple of months later, a glass of wine in hand, with football apparently coming home, I'd like to reflect a little on why there has been such a long break between Build Days 3 and 4, and think a little bit more critically about some of the projects that I'd like to tackle going forward.</p>
<p>I'd started right away on the next project.
The plan was (seemed) quite simple.
I wanted a webapp - something to flex the old TypeScript muscles - which would be a searchable, interactive view of the whole Dinosaur family tree, starting with the earliest proto-dinosaurs and running through to the last species left alive when the meteorite hit.
I've always had an interest in dinosaurs (especially when younger - my mum once sent me in on a dress-up day as a paleontologist) and it seemed like a fun way to revisit some of that while having a go at a new build that I don't think has been attempted before.
How naïve I was.</p>
<p>Let me break down a couple of the challenges I faced.</p>
<h1>1. The Challenge of Trees</h1>
<p>I love me a tree structure.
I guess you could call me a linear algebraist by training (my PhD focused on things like <a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization">NMF</a> and data clustering) so graphs, nodes, and trees are something of a new language to me, but I've been using heirarchical structures for some frontend stuff at work and thinking about tree types in TypeScript got me really interested.
Feeling complacent (a family tree is just a tree, right?) I immediately charged down the route of encoding all the different taxonomic ranks (Genus, Class, Phylum and so on) as nodes in my future tree structure.</p>
<p>That idea fell apart pretty quickly, because as soon as I started looking at how to structure the actual <em>cladograms</em> (new bit of vocab for me there), I realised that many, if not most nodes didn't actually have a taxonomic rank ascribed to them.
Thinking back, that makes total sense.
The classification of a species clearly doesn't depend strictly on its actual evolution.
If that were true, then any given dinosaur species would simply have fewer entries in its classification tree than a modern animal.
The classification is actually <em>closer</em> to the vector/cluster description of a species than its family tree description.</p>
<p>Instead of simply grouping by phylum/class/order/family/genus/species, I'd have to take a much more sophisticated approach to encoding the family tree of each dinosaur.
No problem; more work, no doubt, and a less nicely-structured output (lots of nesting necessary) but doable.</p>
<p>I quickly ran into challenge 2.</p>
<h1>2. The Challenge of Actual Science™</h1>
<p>Although I'd anticipated challenges like the one above (it's a technical problem, after all, and creating good data structures is part of all coding) this next problem was not only the one that's slightly scuppered the project, but one I totally failed to see coming.</p>
<p>It turns out that - shockedpikachu.jpg - science isn't done.
In other words, there is <em>ongoing research</em> into the family trees of dinosaurs.
I know!</p>
<p>I'd decided to start small, work on the Lambeosauridae family first to nail down the interface and the data structures before working in the rest of the group.
It was going well - I'd marshalled a small set of species, arranged a tree for them, and was about ready to start coding up the frontend when I realised there was going to be a real logical problem.</p>
<p>What happens when scientists disagree about the tree?</p>
<p>Naively I thought I might be able to present a menu of options to the end user.
"Would you like Prieto-Marquez 2013 or 2015 [citation]?"
That by itself would be fine apart from the problem of tree-hopping species.
Depending on who you talk to, for instance, <a href="https://en.wikipedia.org/wiki/Arenysaurus">Arenysaurus</a> is either <em>deep</em> into the Lambeosaurini tribe <em>or</em> totally outside it!
Crazy!</p>
<p>Nightmare!</p>
<p>From a coding perspective this does actually pose some serious logical problems.
Let's say I've picked (higher up the tree) some cladogram proposed which shuffles around the Lambeosaurini tribe.
We then have no way of knowing which of the two proposed cladograms for Arenysaurus is compatible.
It's simply not possible to reconcile the trees.</p>
<h1>What's to be done?</h1>
<p>Now if I were going to be <em>really</em> sophisticated, I could take some of the algorithms that are used to <em>generate</em> the cladograms and expose <em>those</em> to the end-user.
That way, they could rearrange the whole tree at will in a nice interactive manner, and moreover perhaps explore some of the interesting differences between them.</p>
<p>That, however, is a much bigger project than I can take on (though the prospect of a second PhD <em>is</em> tempting).
For now, I'm going to have to let sleeping dinosaurs lie, and instead have a crack at something more manageable.</p>
<p>Until the next one, whenever that is.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-27-build_day_3" href="#2021-05-27-build_day_3">Build Day 3</a>
          </span>
                
                    <span class="line"><small>2021-05-27</small></span>
                
            </h1>
            <h1>commit</h1>
<p>Today we publish. The plan is to use GitHub pages, which at first glance seemed
pretty simple but none of the documentation immediately points to how to run
the repo through a build process before publication. So finding that out is
the immediate priority.</p>
<hr />
<p>Half an hour in and this is not nearly as easy as I expected. It seems these
custom builds just aren't really a part of the GitHub ecosystem and... I get
that... but I really think it ought to be achievable with GitHub actions.</p>
<h1>tag</h1>
<p>And another half an hour later and we're live at <a href="https://bm424.github.io/">bm424.github.io</a>!
Turned out to be not that difficult, just a heavy reliance on existing published
actions, which isn't something I'm very used to.</p>
<p>I'm going to write down what happened for my own future reference.</p>
<h2>Self-Tutorial</h2>
<p>There are three basic steps needed:</p>
<ol>
<li>Checkout your own repository. This is accomplished using the public
   "checkout" action, visitable <a href="https://github.com/actions/checkout">here</a>.
   This is surprising to me, as I'd have assumed this was more or less an
   automatic part of the process, but I suppose explicitly doing this is better
   than implicitly assuming it.</li>
<li>Create a version of your <em>own</em> build action. This was actually pretty
   simple, you can directly reference your own Docker image and the entire
   source repo is mounted in, so as long as you're using relative file names
   (normally a sad accident, but here a happy one) it pretty much successfully
   built first time, although I was a little confused about where the action
   was supposed to live (turns out top-level in the repo is fine).</li>
<li>Use yet another public image, this one sourced from a nice little tutorial
   <a href="https://www.pluralsight.com/guides/how-to-host-your-static-webpages-on-github-pages">here</a>,
   to push the site to your branch. A quick skim through the source code
   suggests this does much of the same manual stuff one might have implemented
   (git push to branch etc) but packaged up nice.</li>
</ol>
<p>Moving forward, I'm hoping I'll remember to refer to this repo as a canonical
example for myself.</p>
<p>Until next time.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-26-build_day_2" href="#2021-05-26-build_day_2">Build Day 2</a>
          </span>
                
                    <span class="line"><small>2021-05-26</small></span>
                
            </h1>
            <h1>print()</h1>
<p>So, main changes today include adding support for each posts's metadata,
handling multiple posts building to the same page in the correct order,
and some small updates to improve the site's aesthetics including some
page hierarchy and correct scaling on mobile.</p>
<p>One of the things I find it's really important to do, particularly in personal
projects, is write a few notes to yourself to remind you simply what commands
to write to get things working again. It sounds obvious, but a lot of the actual
minutes spent on a programming project for me are spent working out the correct
order of operations.</p>
<p>For this project, the relevant command is a simple</p>
<pre class="codehilite"><code>docker-compose build &amp;&amp; docker-compose run main
</code></pre>

<p>but in a web project with multiple moving parts these kinds of crucial lines
can be easy to forget or get lost in a maze of possible, often redundant (in
the sense of overlapping functionality) scripts. So when I write a README file,
it's as much for me as for anyone else who might pick up the project.</p>
<h1>.split()</h1>
<p>One thing that came up while coding today was the issue of post permalinks.
I'm not even going to <em>attempt</em> to go there. The quick solution I settled on
was to link to the posts using the file name. As I anticipate I'll be changing
those much less than the titles of the posts, they ought to be permanent enough,
and they map to the titles sufficiently closely to be sensible in the URL.</p>
<p>Come to think of it, this may be similar to what professional static site
generators do, given the mismatch between URLs and post titles that I sometimes
see.</p>
<p>On an unrelated note, using a NamedTuple was a good way to pass values into
the Jinja templates quickly, but it's quickly showing its limitations. I've
been using Pydantic a lot at work and I like it a lot, we'll see if I need to
get it involved here, depending on how much the complexity of the NamedTuple
structure increases.</p>
<h1>:focus</h1>
<p>To wrap up, I spent a fair bit of time faffing around with the style of the
anchor links to the posts. This is actually the kind of thing I tend to find
really fun, because webpage style is one of the ways it's easy to get a little
creative in projects like this. That said, I often get carried away in style
over substance. Part of this project is to focus on getting the content out,
rather than perfecting style, so with these final changes I'm going to call
it a day and implement the GitHub pages build another time.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-23-build_day_1" href="#2021-05-23-build_day_1">Build Day 1</a>
          </span>
                
                    <span class="line"><small>2021-05-23</small></span>
                
            </h1>
            <h1>import</h1>
<p>A couple of hours later and we have a working static site builder running
locally using Docker, Python, Jinja2, markdown, and not much else. On the
whole I'm pretty happy with the timing, particularly considering a fairly
significant chunk of that was actually writing the build day 0 content.</p>
<p>I initially thought I'd be needing a running server to see changes live, but
quickly realised that was going to be unnecessary - the Docker rebuild was
more than quick enough to get a fast feedback loop going, and the most
fiddly bit, the CSS, I could actually just do in the build styles, refreshing
the page in the meantime, then copy back into the source when done.</p>
<h1>next()</h1>
<p>Simple enough so far. However, having now added this next file, I need to make
a couple of changes to ensure one can navigate to past entries, and then it
should be a simple case of deploying to GitHub pages.</p>
<p>I say that. I've done it before, but quite a long time ago (my company uses
GitLab, so I'm a little out of practice)... so see you in the next entry.</p>
<h1>wraps()</h1>
<p>I've slightly backdated this post because these reflections were based on the
hour or two of work I did after writing the first day's post a couple of days
ago, and I want to spend a bit of time after today (2021-05-26) reflecting
on today's work instead. Just for transparency's sake...</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-23-build_day_0" href="#2021-05-23-build_day_0">Build Day 0</a>
          </span>
                
                    <span class="line"><small>2021-05-23</small></span>
                
            </h1>
            <h1>def</h1>
<p>All projects begin somewhere, and this is where this one begins.</p>
<p>Over the next few weeks and months, I'll be building a personal
portfolio/showcase of code projects, each chosen for both personal interest
and to demonstrate my use of particular technologies, such as the web stack,
machine learning, or programming interface development.</p>
<h1>__doc__</h1>
<p>Why?</p>
<p>Well, firstly, a lot of the code I write is for the company I work for,
and so while the things I can do has expanded significantly over the last few
years, none of it is particularly reflected in my GitHub profile, and I'd like
to bring that up to date.</p>
<p>Secondly, I want to create a coding space for myself that is less restricted
by deadlines and "product" pressure, to try and focus on best practices,
and to exercise older programming skills I used to use regularly (such as
in training neural networks).</p>
<p>And lastly, I think the projects I've lined up are going to be a lot of fun,
and by tackling some of them I hope I can rekindle my enthusiasm for hobbyist
programming.</p>
<h1>__call__</h1>
<p>So what are these projects to be? In order of increasing complexity:</p>
<ol>
<li>This! A simple static site generator, from scratch, written in Python and
   markdown, where I can record my progress and thoughts on each project
   as I go.</li>
<li>A bit of a personal exercise, writing a simple Schrödinger equation
   solver in Python, with graphical output. If it goes well, I'll convert
   it into a web app.</li>
<li>A dinosaur family tree/cladogram, implemented as a web app using React
   and/or Redux, interactive, searchable, and live on the web.</li>
<li>A board game, called Bao, which I learned as a kid on holiday in Zanzibar,
   implemented in Rust using Bevy.</li>
<li>An open street map tile neural network tile generator, implemented in
   Python and, if all goes well, deployed as a web app.</li>
</ol>
<h1>__exit__</h1>
<p>This particular post was written before any code, and represents simply
the starting point for project 1. Next post, I'll be writing up reflections
on the implementation of this little custom static site generator. If you've
read this far, thanks! And see you next time.</p>
        </article>
    
</main>
<footer>
    <nav>
        <ol>
            
                <li><a href="#2022-12-19-functional_graph_algorithms_1">2022-12-19</a></li>
            
                <li><a href="#2021-07-09-build_day_5">2021-07-09</a></li>
            
                <li><a href="#2021-07-08-build_day_4">2021-07-08</a></li>
            
                <li><a href="#2021-05-27-build_day_3">2021-05-27</a></li>
            
                <li><a href="#2021-05-26-build_day_2">2021-05-26</a></li>
            
                <li><a href="#2021-05-23-build_day_1">2021-05-23</a></li>
            
                <li><a href="#2021-05-23-build_day_0">2021-05-23</a></li>
            
        </ol>
    </nav>
</footer>
</body>
</html>