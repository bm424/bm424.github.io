<!doctype html>
<html lang="en">
<head>
    <title>bm424</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&family=Raleway&display=swap"
          rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
    <link href="highlight-styles.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<main>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2023-01-02-functional_graph_algorithms_3" href="#2023-01-02-functional_graph_algorithms_3">Implementing Functional Graph Algorithms in Python (Part 3: Algorithms)</a>
          </span>
                
                    <span class="line"><small>2023-01-02</small></span>
                
            </h1>
            <p><em>This article was originally published on
Medium (<a href="https://medium.com/@benhmartineau/implementing-functional-graph-algorithms-in-python-part-3-algorithms-a305751f9d41">link</a>)</em></p>
<hr />
<p>Welcome back to this series on functional programming in Python! We’ve been looking at how to implement <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/inductive-graphs-and-functional-graph-algorithms/2210F7C31A34EA4CF5008ED9E7B4EF62">inductive
graphs</a> (
Erwig 2001) in Python. In the <a href="#2022-12-19-functional_graph_algorithms_1">first part</a>, we looked at how to implement the
necessary data types, and in the <a href="#2022-12-26-functional_graph_algorithms_2">second part</a> we implemented some basic
functions.</p>
<p>In this section, I’ll show you how to implement topological sorting and Dijkstra’s algorithm for shortest paths using
the methods described in the paper. We’ll use new Python features like <code>match</code> statements to get very close to the
declarative Haskell description of these algorithms.</p>
<h1>Topological Sorting</h1>
<p>A <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> of a graph is a list of its nodes which are
followed in an order where “earlier” nodes come before "later" nodes (for a more precise definition see the linked
Wikipedia article). Strictly speaking, this is only possible if the graph is acyclic — this means there are no loops.
It’s useful for resolving the “order” that processes should be evaluated in if, for example, your graph represents data
flow. Topological sorts are not unique.</p>
<h2>Depth-First Forest</h2>
<p>The paper describes an inductive graph algorithm for the topological sort which relies on a "depth-first forest" which
can be derived from the graph. What is this?</p>
<p><img alt="A single graph with seven nodes, the first two labeled 'a' and 'b', with directed edges joining some of the other nodes. An arrow labeled 'dff' shows the transformation to the depth first forest. The forest shows the same seven nodes, but 'a' and 'b' now represent the roots of two separate subtrees." src="depth_first_forest.png" /></p>
<p><em>An illustration of the operation of "depth first forest" on a graph.</em></p>
<p>We can decompose the graph into a number of “trees”. Trees are like graphs but nodes only ever have one predecessor.
Starting at any node, we can get a single tree by removing it and following successors until we run out of nodes. To get
the forest, we just need to start searching from all nodes. The algorithm described in Haskell notation looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">df</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Node</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">([</span><span class="kt">Tree</span><span class="w"> </span><span class="kt">Node</span><span class="p">],</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="nf">df</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>
<span class="nf">df</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="kt">:</span><span class="n">vs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Br</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">f</span><span class="kt">:</span><span class="n">f&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">g₂</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">g₁</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">df</span><span class="w"> </span><span class="p">(</span><span class="n">suc</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="n">f&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">g₂</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">df</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="n">g₁</span>
<span class="nf">df</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="kt">:</span><span class="n">vs</span><span class="p">)</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">df</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="n">g</span>
</code></pre></div>

<h2>Implementation</h2>
<p>Phew! That’s a confusing definition. Let’s break it down in Python. Firstly, the function says that given a queue of
nodes <code>[Node]</code> and a graph <code>Graph a b</code>, <code>df</code> returns a tuple (a Haskell-style tuple with a fixed length). The first
element of
the tuple is a queue of trees of nodes, and the second is a graph. Since we’re using methods to implement these
functions in Python, it’s almost the same:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_dff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]:</span>
        <span class="o">...</span>
</code></pre></div>

<p>The next line, <code>df [] g = ([], g)</code>, says that if there are no nodes, we just return an empty tuple and the graph itself:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_dff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(),</span> <span class="bp">self</span>
        <span class="o">...</span>
</code></pre></div>

<p>The line after this, <code>df (v:vs) (c &amp;v g) = (Br v f:f', g₂) where (f, g₁) = df (suc c) g; (f', g₂) = df vs g₁</code>, says: if
we
can find the first node, <code>v</code>, in the graph, then calculate the forest for all of the successors of that node in the
graph
<em>without</em> that node. Then, carry on calculating trees with whatever nodes <code>vs</code> we haven’t yet looked at. We then
construct a
tree with the node at the head of the forest of successors, then return it alongside all the other trees we’ve found.</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_dff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]:</span>
        <span class="o">...</span>
        <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">nodes</span>  <span class="c1"># (v:vs)</span>
        <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>  <span class="c1"># (c &amp;v g)</span>
            <span class="k">case</span> <span class="n">c</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span>
                <span class="n">f</span><span class="p">,</span> <span class="n">g1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_dff</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">suc</span><span class="p">)</span>  <span class="c1"># (f, g1) = df (suc c) g</span>
                <span class="n">f_</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">_dff</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span>  <span class="c1"># (f&#39;, g2) = df vs g1</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="o">*</span><span class="n">f_</span><span class="p">),</span> <span class="n">g2</span>  <span class="c1"># (Br v f:f&#39;, g2)</span>
</code></pre></div>

<p>Why have I used match-case here? Well, what happens if we can’t find the node <code>v</code> in the graph? We just carry on with
the
other nodes, as in the final line of the algorithm <code>df (v:vs) g = df vs g</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_dff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]:</span>
        <span class="o">...</span>
        <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">nodes</span>  <span class="c1"># (v:vs)</span>
        <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>  <span class="c1"># (c &amp;v g)</span>
            <span class="k">case</span> <span class="n">c</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span>
                <span class="o">...</span>
            <span class="n">case</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dff</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span>  <span class="c1"># df vs g</span>
</code></pre></div>

<p>So the match statement allows a nice clean syntax demonstrating both cases.</p>
<p>Finally, we can wrap the whole thing in a public <code>dff</code> method which just passes all of the graph’s nodes into the
function, so that we get back a forest that spans the whole graph:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_dff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">dff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div>

<p>The topological sort of the graph is derived from the depth-first spanning forest. We can walk through each tree from
the bottom up (using a function called <code>postOrder</code>). The reverse of this sequence is a topological sort!</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_dff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">dff</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">topsort</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">concat_map</span><span class="p">(</span><span class="n">Tree</span><span class="o">.</span><span class="n">post_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dff</span><span class="p">())))</span>
</code></pre></div>

<p>Isn't that sweet?</p>
<h1>Dijkstra's Shortest Path Algorithm</h1>
<p>Finally, let’s implement the inductive graph version of Dijkstra’s shortest path algorithm. There’s a bit of underlying
machinery here involving what the paper calls <code>LRTrees</code> and <code>LPaths</code> which I won’t get in to here, but feel free to take
a
look at the code. The important thing for the implementation is that <code>LPaths</code> are labeled lists of nodes which can be
compared using <code>&lt;</code> — i.e. one is “shorter” than another. This means they can be used in a heap.</p>
<h2>Definition</h2>
<div class="codehilite"><pre><span></span><code><span class="nf">dijkstra</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Heap</span><span class="w"> </span><span class="p">(</span><span class="kt">LPath</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">LRTree</span><span class="w"> </span><span class="n">b</span>
</code></pre></div>

<p>This says that for a graph with node edges labeled with a real number, and a heap (a data structure where we can
efficiently get the smallest value) of paths, <code>dijkstra</code> will return a <code>LRTree</code> (a queue of labeled paths) representing
the shortest paths between a given node and all other reachable nodes.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">dijkstra</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isEmptyHeap</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">isEmpty</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
</code></pre></div>

<p>Simple enough: there are no short paths in an empty graph. For non-empty graphs, the heap should never be empty, because
we always have a zero-length path from a node to itself.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">dijkstra</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">@</span><span class="p">((</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">)</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span><span class="err">≺</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p</span><span class="kt">:</span><span class="n">dijkstra</span><span class="w"> </span><span class="p">(</span><span class="n">mergeAll</span><span class="w"> </span><span class="n">h</span><span class="kt">:</span><span class="n">expand</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="n">g</span>
</code></pre></div>

<p>😱 What is this nightmare? In words, it says: if the first node <code>v</code> in the smallest path <code>p</code> in the heap can be found in
the graph, return that path and keep searching with <code>v</code> removed and a heap with that path removed and a set of new paths
starting at all the successors. What this means is that when a new, shorter path to a given node is found it replaces
the existing one.</p>
<p>Finally, if the shortest path’s first node <code>v</code> is not in the graph, we can just carry on with trying to find shorter
paths than the ones we’ve got:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">dijkstra</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="err">≺</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">dijkstra</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">g</span>
</code></pre></div>

<h2>Implementation</h2>
<p>Like the topological sort, this algorithm maps very nicely to Python. I’ve included the _<code>expand</code> method for
completeness:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span>
            <span class="n">item</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lpath</span><span class="p">:</span> <span class="s2">&quot;LPath[float]&quot;</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ImmutableHeap</span><span class="p">[</span><span class="s2">&quot;LPath[float]&quot;</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">ImmutableHeap</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">LPath</span><span class="p">((</span><span class="n">LNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">item</span> <span class="o">+</span> <span class="n">label</span><span class="p">),</span> <span class="o">*</span><span class="n">lpath</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">successors</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dijkstra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heap</span><span class="p">:</span> <span class="n">ImmutableHeap</span><span class="p">[</span><span class="s2">&quot;LPath[float]&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;LRTree[float]&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">heap</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>  <span class="c1"># isEmptyHeap h || isEmpty g</span>
            <span class="k">return</span> <span class="n">LRTree</span><span class="p">()</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># p &lt; h</span>
        <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">p</span>  <span class="c1"># p@((v, d): _)</span>
        <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>  <span class="c1"># c &amp;v g</span>
            <span class="k">case</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">LRTree</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">_dijkstra</span><span class="p">(</span><span class="n">ImmutableHeap</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">))))</span>
                <span class="p">)</span>  <span class="c1"># p:dijkstra (mergeAll (h:expand d p c) g</span>
            <span class="n">case</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dijkstra</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>  <span class="c1"># dijkstra h g</span>
</code></pre></div>

<p>With a list of shortest paths, we now just need some wrapper functions to complete the implementation:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_spt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;LRTree[float]&quot;</span><span class="p">:</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="n">ImmutableHeap</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="n">LPath</span><span class="p">((</span><span class="n">LNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dijkstra</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</code></pre></div>

<p>Note that there is a typo in the linked version of the paper which incorrectly defines <code>spt</code>, i.e. the shortest paths
from <code>t</code>, as</p>
<div class="codehilite"><pre><span></span><code><span class="nf">spt</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">spt</span><span class="w"> </span><span class="p">(</span><span class="n">unitheap</span><span class="w"> </span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)])</span>
</code></pre></div>

<p>where it should read</p>
<div class="codehilite"><pre><span></span><code><span class="nf">spt</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">dijkstra</span><span class="w"> </span><span class="p">(</span><span class="n">unitheap</span><span class="w"> </span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)])</span>
</code></pre></div>

<h2>Validation</h2>
<p>Let’s check it works! Wikipedia has an article on Dijkstra’s algorithm where it shows a simple small graph labeled 1–6.</p>
<p><img alt="An animation demonstrating Dijkstra's algorithm implemented the 'normal' way, showing an undirected, labeled graph with six nodes. Starting at the node labeled '1', the animation shows how each node is visited in turn and tagged with a value representing the shortest path to that node, until the shortest path to the destination is tagged. The final shortest path is 1, 3, 6, 5, with a total length of 20" src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif" /></p>
<p><a href="https://en.wikipedia.org/wiki/File:Dijkstra_Animation.gif"><em>https://en.wikipedia.org/wiki/File:Dijkstra_Animation.gif</em></a></p>
<p>The shortest graph from Node 1 to Node 5 goes through 3 and 6. Given everything we’ve implemented so far, we can now
construct this graph with all the edges and test our algorithm:</p>
<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Adj</span><span class="p">(((</span><span class="mi">7</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">)))))</span>
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Adj</span><span class="p">(((</span><span class="mi">10</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">)))))</span>
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Adj</span><span class="p">(((</span><span class="mi">11</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">)),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">)))))</span>
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">Adj</span><span class="p">(((</span><span class="mi">6</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">)),)))</span>
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">Adj</span><span class="p">(((</span><span class="mi">9</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">)),)))</span>
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="mi">6</span><span class="p">,</span> <span class="n">Adj</span><span class="p">())</span>
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="n">EmptyGraph</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">undir</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span><span class="o">.</span><span class="n">sp</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">(1, 3, 6, 5)</span>
</code></pre></div>

<p>That puts a smile on my face.</p>
<h1>Conclusion</h1>
<p>We’ve seen how to implement some functional algorithms for graphs in Python, and how closely we can approach the Haskell
descriptions using Python syntax like destructuring and <code>match</code> statements. In the next and final part I’m going to give
my overall thoughts about this exercise, and draw some conclusions about functional programming in Python. See you
there!</p>
<h1>References</h1>
<ol>
<li>Erwig, Martin. “Inductive graphs and functional graph algorithms.” <em>Journal of Functional Programming</em> 11.5 (2001):
   467–492.</li>
</ol>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2022-12-26-functional_graph_algorithms_2" href="#2022-12-26-functional_graph_algorithms_2">Implementing Functional Graph Algorithms in Python (Part 2: Functions)</a>
          </span>
                
                    <span class="line"><small>2022-12-26</small></span>
                
            </h1>
            <p><em>This article was originally published on
Medium (<a href="https://medium.com/@benhmartineau/implementing-functional-graph-algorithms-in-python-part-2-functions-cf15e640c7c3">link</a>)</em></p>
<hr />
<p>Hello! Welcome to the second part of this series on functional programming in Python. If you haven’t read the first part
yet, check it out <a href="#2022-12-19-functional_graph_algorithms_1">here</a>.</p>
<p>In this series, we’re implementing “inductive graphs” as described
in <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/inductive-graphs-and-functional-graph-algorithms/2210F7C31A34EA4CF5008ED9E7B4EF62">this paper</a> (
Erwig 2001). In the first part, we
defined the basic data structures, and we’ll now move on to implementing the necessary abstract methods and some basic
algorithms. As a reminder, you can find all of the code for these articles at
the <a href="https://github.com/bm424/inductive-graph-algorithms"><code>inductive-graph-algorithms</code></a> repository
over on GitHub.</p>
<h1>Abstract Methods</h1>
<p>Take a look at Table 1 in the paper. It explains that for inductive graph algorithms, we need three basic features for
the graph:</p>
<ol>
<li>A test for emptiness.</li>
<li>The ability to extract an arbitrary context from the graph.</li>
<li>The ability to extract a specific context from the graph.</li>
</ol>
<p>How we choose to implement these features is up to us. I’ve chosen to implement the test for emptiness as a property of
the graph, and the context extraction as a method <code>.pop(node: Optional[Node])</code> on the graph:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the graph is empty (contains no nodes), False otherwise.&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts a given `node` from the graph.</span>

<span class="sd">        Returns the node&#39;s context, and the remaining graph. If `node` is None, any</span>
<span class="sd">        node may be extracted. If `node` is not in the graph, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</code></pre></div>

<p>Now let’s implement these for our subtypes! For the empty graph, it’s easy enough:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">EmptyGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>

<p>The empty graph is, obviously, empty, and we can never extract any context from it.</p>
<p>The inductive graph implementation is more complicated:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">InductiveGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="s2">&quot;Graph[A, B]&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>
        <span class="n">node_context</span><span class="p">,</span> <span class="n">graph_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">sub_node_context</span><span class="p">,</span> <span class="n">subgraph</span> <span class="o">=</span> <span class="n">match</span>
            <span class="k">return</span> <span class="n">node_context</span> <span class="o">|</span> <span class="n">sub_node_context</span><span class="p">,</span> <span class="n">graph_context</span> <span class="o">&amp;</span> <span class="n">subgraph</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>

<p>Let’s dig into <code>pop</code> here.</p>
<p>First, if <code>node</code> is <code>None</code>, it means we can return any arbitrary context alongside the remaining graph. The way we’ve
implemented <code>InductiveGraph</code> makes this very easy — we simply return the head, which is a context, and the tail, which
by
construction never refers to any node mentioned in the head. We can do exactly the same if the specific node requested
happens to be the head node.</p>
<p>If neither of the two conditions above is satisfied, it’s time for some recursion! First, we take the head context and
split it into two parts. The first part contains any references to node, inverted so that <code>node</code> is the node of the
context — this is <code>node_context</code>. The second part contains any references that are not to <code>node</code>.</p>
<p><img alt="An illustration of how the &quot;head&quot; node of a graph is decomposed into two contexts. One context, called &quot;node_context&quot;, centres on &quot;node&quot;, and contains only references between &quot;node&quot; and &quot;head&quot;. The other context, called the &quot;graph_context&quot;, centres on &quot;head&quot;, and contains only any
_other_ references to &quot;head&quot;." src="graph_context_pop.png" /></p>
<p><em>Splitting the head into component parts.</em></p>
<p>Then, we try to pop <code>node</code> from <code>tail</code>, meaning that we start again with <code>pop</code>! Eventually, we must either reach <code>node</code>,
or find
that <code>node</code> is not in the graph. Either way, the recursion terminates at some point.</p>
<p>What happens if we reach <code>node</code>? <code>pop</code> returns a tuple of <code>node_context | sub_node_context</code>
and <code>graph_context &amp; subgraph</code>. The
first part of this joins all of the node_contexts together into a single context - the one we want extracted! Every
reference to <code>node</code> in the graph is encapsulated in a new context with <code>node</code> at the center. The second part
re-constructs a
graph from all of the contexts which don't contain <code>node</code> - the remainder.</p>
<p>That's a lot of behaviour wrapped up in one little function, so let's go over it slowly once more.</p>
<ol>
<li>If the head is the context of the node we need, return it and the remaining graph.</li>
<li>Otherwise, break the head into parts. One part contains any references to the node we need, the other part contains
   no references to the node we need.</li>
<li>Repeat the above process with the tail.</li>
<li>Once we have the context of the node we need, join all the contexts that do reference the node into our extracted
   context, and construct a graph from the contexts that do not reference the node.</li>
</ol>
<p>Phew 😅 With that tricky part out the way, we can get on to some sweet implementations!</p>
<h1>Basic Functions</h1>
<p>Back in Part 1, I said that we could define functions on inductive graphs analogous to <code>reduce</code> and <code>map</code> for lists.
Let's
do that now!</p>
<h2><code>ufold()</code></h2>
<p>In the paper, <code>reduce</code> for graphs is called <code>ufold</code>. <code>fold</code> is an often-used synonym for <code>reduce</code> in functional
programming, and
<code>ufold</code> means the fold on graphs is "unordered," because the nodes are, in general, traversed in arbitrary order.</p>
<p>The paper describes the <code>ufold</code> function in the following way:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">ufold</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Context</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span>
<span class="nf">ufold</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">u</span>
<span class="nf">ufold</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">ufold</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>
</code></pre></div>

<p>This means: take a graph, a starting value of type <code>c</code>, and a function which takes something of type <code>c</code> and a <code>Context</code>
to
produce a result <code>c</code>. <code>ufold</code> will then produce a result of type <code>c</code>. Yes, it's a higher-order function which takes
another
function as a parameter! <code>ufold</code> over an empty graph is just the starting value, but for anything else we extract an
arbitrary context, then apply the function over that context and the result of <code>ufold</code> on the remainder. More recursion!</p>
<p>Thankfully, this is actually pretty concise in Python:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">ufold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="n">C</span><span class="p">],</span> <span class="n">C</span><span class="p">],</span> <span class="n">u</span><span class="p">:</span> <span class="n">C</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Un-ordered fold.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">u</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># c &amp; g</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">ufold</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>  <span class="c1"># f c (ufold f u g)</span>
</code></pre></div>

<h2><code>nodes()</code></h2>
<p>How do we use <code>.ufold()</code>? Well, let's say we want to get the nodes of the graph. In Haskell syntax, the function looks
like this:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">nodes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Node</span><span class="p">]</span>
<span class="nf">nodes</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ufold</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="kt">:</span><span class="p">))</span><span class="w"> </span><span class="kt">[]</span>
</code></pre></div>

<p>In simple words, this says that the nodes of the graph are just appended one by one to an initially-empty list. In
Python, it looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The nodes of the graph.&quot;&quot;&quot;</span>
        <span class="c1"># ufold (\(p, v, l, s) -&gt; (v:)) []</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ufold</span><span class="p">(</span><span class="k">lambda</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">),</span> <span class="p">())</span>
</code></pre></div>

<p>That's pretty concise, and again it mirrors the Haskell definition pretty closely.</p>
<h2><code>gmap()</code></h2>
<p><code>gmap</code> is the graph's equivalent of <code>map</code> and we can use <code>ufold</code> to implement it!</p>
<div class="codehilite"><pre><span></span><code><span class="nf">gmap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Context</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Context</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span>
<span class="nf">gmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ufold</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;</span><span class="p">))</span><span class="w"> </span><span class="kt">Empty</span>
</code></pre></div>

<p>In other words, <code>gmap</code> is a function that takes a graph and a function that converts a context into another context, and
produces another graph. We can implement it by applying the function to each context, and constructing a graph from the
result. In Python:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">gmap</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]],</span> <span class="n">Context</span><span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Graph[C, D]&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the graph into another graph via `fn` over its contexts.&quot;&quot;&quot;</span>
        <span class="c1"># ufold (\c -&gt; f c &amp;) Empty</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ufold</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">context</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">fn</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="n">EmptyGraph</span><span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]()</span>
        <span class="p">)</span>
</code></pre></div>

<h1>Conclusion</h1>
<p>The inductive graph definition requires just three features: a test for emptiness, the removal of an arbitrary node's
context, and the removal of a specific node's context. With those in place, we can create some very succinct functions
to form the basis of our functional graphs: <code>ufold</code>, and <code>gmap</code>.</p>
<p>In the next part, we'll implement some more complex algorithms including Dijkstra's algorithm and topological sorting.</p>
<h1>References</h1>
<ol>
<li>Erwig, Martin. "Inductive graphs and functional graph algorithms." <em>Journal of Functional Programming</em> 11.5 (2001):
   467–492.</li>
</ol>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2022-12-19-functional_graph_algorithms_1" href="#2022-12-19-functional_graph_algorithms_1">Implementing Functional Graph Algorithms in Python (Part 1: Data Types)</a>
          </span>
                
                    <span class="line"><small>2022-12-19</small></span>
                
            </h1>
            <p><em>This article was originally published on
Medium (<a href="https://medium.com/@benhmartineau/implementing-functional-graph-algorithms-in-python-part-1-data-types-b9ef1e3742e5">link</a>)</em></p>
<hr />
<p>If you've ever read articles about functional programming in Python, you probably already know about <code>map</code>, <code>filter</code>, and
<code>reduce</code>, which are useful functions for functional programming using lists. However, if you're like me, you may have
sometimes felt that articles like that are a bit shallow, and don't really teach you anything about how to use Python as
a functional programming language in general. I'd like to show you a more challenging functional programming problem,
and demonstrate that Python has a great syntax for writing elegant, concise functional code.</p>
<p>This will be a four-part series. In this part, I'll be describing the problem of functional graph algorithms, and
setting up basic data structures. In Part 2, I'll implement the basic functions we'll need to write more expressive
algorithms, which we'll cover in Part 3. Finally, I'll give you my final thoughts on this exercise (a "retro", if you
like) in Part 4.</p>
<p>You can find all of the code for these articles at
the <a href="https://github.com/bm424/inductive-graph-algorithms"><code>inductive-graph-algorithms</code></a> repository over on GitHub.</p>
<h1>The Problem</h1>
<p>Many programmers will have had to do some work with data structures like trees, such as JSON data or web documents, or
graphs, such as are used in data processing frameworks like Airflow. A few months ago, I was working on designing a
system with a graph-like structure. I'm a big fan of functional programming, so I started wondering: how does a
functional program implement algorithms like <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a>?</p>
<p>In the world of imperative programming, topological sorting is not very difficult — Kahn's algorithm and a depth-first
search algorithms are both described on the Wikipedia page linked above. However, both rely on stateful mutations of the
graph's nodes, because they need us to keep track of visited nodes via a label. Stateful changes should not be part of
our functional implementation.</p>
<h1>The Solution</h1>
<p>After a little bit of googling, I came
across <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/inductive-graphs-and-functional-graph-algorithms/2210F7C31A34EA4CF5008ED9E7B4EF62">this paper</a> 
(Erwig 2001), which describes the principle of "inductive"
graphs, and forms the basis of Haskell's functional graph library <code>fgl</code>. I'll try to quickly explain inductive graphs by
analogy to a list, but for a more detailed explanation see
this <a href="https://math.stackexchange.com/a/1224804">StackExchange answer</a> and its linked blog post — they're
both excellent.</p>
<p>When we take a sequence like a list or a tuple, and remove an item, we produce a pair: the item, and a new list or tuple
with all the existing items except for the one we just removed. We can then repeat the operation on the new list.
Functions like <code>map</code>, <code>filter</code>, and <code>reduce</code> can be concisely defined because of this repetition.</p>
<p><img alt="A diagram with four parts, representing generalised functional operations on sequences. In part 1, a series of 5 circles
are joined together with lines, representing a list. In part 2, the first circle is separated and highlighted,
representing its removal and usage in some functional operation. Part 3 shows the 4 remaining circles, and part 4 shows
the removal of the first circle as in part 2." src="functions_over_lists.png" /></p>
<p><em>Basic operation for functions over lists: 1) Start with a list of any length. 2) Remove the first item and perform some
operation. 3) You now have a smaller list. 4) Repeat from step 2.</em></p>
<p>An inductive graph has a similar property. Instead of removing a single item, we remove a node and all of its connected
edges, returning a graph without any reference to the node we just removed. We can then repeat the operation on the new
graph. This means we can define functions analogous to <code>map</code>, <code>filter</code>, and <code>reduce</code> for an inductive graph, and go
further,
implementing depth-first walks, shortest-path algorithms, and, indeed, topological sorts.</p>
<p><img alt="A diagram with four parts, representing generalised functional operations on graphs. In part 1, a series of 5 circles
are joined together with lines, representing a graph. In part 2, an arbitrary circle is separated and highlighted,
representing its removal and usage in some functional operation. Part 3 shows the 4 remaining circles, and part 4 shows
the removal of another arbitrary circle as in part 2." src="functions_over_graphs.png" /></p>
<p><em>Basic operation for inductive functions over graphs: 1) Start with any graph. 2) Remove a node and all of its edges and
perform some operation. 3) You now have a smaller graph. 4) Repeat from step 2.</em></p>
<h1>Implementation</h1>
<h2>Notes</h2>
<p>The paper describes its data structures and functions in Haskell syntax, so we need to work out how to convert this into
Python. I've generally adopted the following approach:</p>
<ol>
<li>Types and data types are implemented as classes, and where the types need to be destructured I've
   implemented <code>__iter__</code>
   so that we can use Python's destructuring (for example <code>x, *y = […]</code>) to closely match the definition.</li>
<li>I've implemented most of the functions as methods on the classes, rather than external functions, because it keeps
   the
   code organised and "more Pythonic".</li>
<li>"Queues" are ordered sequences — I've used tuples rather than lists to prevent accidental mutation. In some
   algorithms,
   the order doesn't matter and for these cases I've used the builtin <code>frozenset</code>, rather than plain <code>set</code>s, again to
   avoid
   accidental mutation.</li>
<li>Later in the paper, a "heap" is used for shortest-path algorithms. Python has built-in efficient heap algorithms in
   the
   <code>heapq</code> package, but these rely on mutating lists in-place. I implemented a wrapper class which helps ensure
   immutability.</li>
</ol>
<h2>Node</h2>
<p>The very first type described in the paper is the type</p>
<div class="codehilite"><pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span>
</code></pre></div>

<p>That's right, nodes are integers. Actually, we can think of this as being like the index of an item in the list — the
node type is the "index" of the node in the graph. In Python:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A node.</span>

<span class="sd">    For convenience, nodes are represented by integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div>

<p>Simple!</p>
<h2>"Adj"</h2>
<div class="codehilite"><pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="kt">Adj</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">Node</span><span class="p">)]</span>
</code></pre></div>

<p>This is a bit more abstract. It means that <code>Adj</code> is a sequence of tuples. Each tuple represents an edge in the graph,
and
<code>b</code> represents the edge's label, which can be anything, so we leave it generic. Note that edges are directed: <code>Adj</code> may
describe a connection to or from a given node, but by itself it doesn't care which.</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Adj</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">Node</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjacency relationships.&quot;&quot;&quot;</span>

    <span class="n">labeled_nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labeled_nodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">Node</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_nodes</span> <span class="o">=</span> <span class="n">labeled_nodes</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Adj(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_nodes</span><span class="si">!r}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_nodes</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_nodes</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">labeled_nodes</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Adj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_nodes</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">labeled_nodes</span><span class="p">)</span>
</code></pre></div>

<p>I've made this class inherit from the Sequence class, which means if we implement <code>__len__</code> and <code>__getitem__</code> we get
iteration for free. I've also specified <code>__eq__</code> and <code>__add__</code> so that the class behaves like a tuple.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">Context</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Context</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Adj</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">Node</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Adj</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
</code></pre></div>

<p>More abstract again! This says that a "context" comprises four parts: an adjacency relationship, a node, the label of
that node (<code>a</code>), and another adjacency relationship. The first <code>Adj</code> represents edges directed towards <code>Node</code>, called
"predecessors", and the second <code>Adj</code> represents edges directed away from <code>Node</code>, called "successors". It's important to
note
that, for inductive graphs, this doesn't have to be all of the connected nodes, because other <code>Context</code>s may define
additional <code>Adj</code> relationships.</p>
<p>There are two generic types here: <code>a</code> is the type of the node's label, and <code>b</code> is the type of the edge's label.</p>
<p><img alt="A diagram showing the &quot;context&quot; of a node in an inductive graph. There are four circles, of which one is central and
highlighted. It has a highlighted arrow, labelled &quot;predecessor&quot;, directed towards it from one of the other circles.
Another highlighted arrow, labelled &quot;successor&quot; is directed out of it toward one of the other circles. Another arrow,
not highlighted, points towards the last circle, and is labelled &quot;Another node's ‘Adj'&quot;." src="context_in_inductive_graph.png" /></p>
<p><em>Anatomy of a "Context": predecessor edges pointing to this node, successor edges pointing away from this node, and a
label of arbitrary type on the node itself. Note that a "Context" doesn't necessarily refer to all of the edges
connecting into a node, because these might be parts of other "Context"s.</em></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Context</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A context.</span>

<span class="sd">    A node&#39;s context describes (some of) its surroundings, including its label, its </span>
<span class="sd">    adjacent predecessors and its adjacent successors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">predecessors</span><span class="p">:</span> <span class="n">Adj</span><span class="p">[</span><span class="n">B</span><span class="p">]</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">Node</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">A</span>
    <span class="n">successors</span><span class="p">:</span> <span class="n">Adj</span><span class="p">[</span><span class="n">B</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">predecessors</span><span class="p">:</span> <span class="n">Adj</span><span class="p">[</span><span class="n">B</span><span class="p">],</span>
            <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
            <span class="n">label</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span>
            <span class="n">successors</span><span class="p">:</span> <span class="n">Adj</span><span class="p">[</span><span class="n">B</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span> <span class="o">=</span> <span class="n">predecessors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">successors</span> <span class="o">=</span> <span class="n">successors</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Context(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="si">!r}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">predecessors</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">node</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">successors</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">successors</span>
        <span class="p">)</span>
</code></pre></div>

<h2>Graph</h2>
<p>Finally, we can describe a graph itself:</p>
<div class="codehilite"><pre><span></span><code><span class="kr">data</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Context</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="kt">Graph</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>
</code></pre></div>

<p>This says that a graph is either an empty graph OR a context attached (using the operator <code>&amp;</code>) to a graph.</p>
<p>Python doesn't have variant types like this, but we can use inheritance instead. We'll define an abstract <code>Graph</code> class
that will have two subclasses: <code>EmptyGraph</code> and <code>InductiveGraph</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An abstract graph&quot;&quot;&quot;</span> 
</code></pre></div>

<p>The <code>InductiveGraph</code> will contain a "head", which is the Context a b, and a "tail", which is another graph.</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">EmptyGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An empty graph, containing no nodes or edges.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;EmptyGraph&quot;</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">InductiveGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An inductive graph.</span>

<span class="sd">    The `head` of the graph is a context that can only refer to nodes in the `tail`,</span>
<span class="sd">    which is also a graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">head</span><span class="p">:</span> <span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Graph</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Context</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="n">tail</span><span class="p">:</span> <span class="n">Graph</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="si">!r}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="si">!r}</span><span class="s2">&quot;</span>
</code></pre></div>

<h2>Construction</h2>
<p>As well as the data itself, we can implement the constructor operator <code>&amp;</code> using Python! In the paper, we imagine
building
up graphs right-to-left, starting with the empty graph, and adding on context until we reach the whole graph:</p>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EmptyGraph</span><span class="p">()</span>
</code></pre></div>

<p><img alt="A diagram illustrating the construction of inductive graphs using the &quot;&amp;&quot; operator. At the top, a collection of circles,
some of which have lines attached, are aligned with the &quot;&amp;&quot; operator separating them. On the right hand side is a circle
with a line through it representing the empty graph. At the bottom is an &quot;equals&quot; sign followed by a complete graph
formed of the parts above." src="constructing_inductive_graph.png" /></p>
<p><em>Principle for constructing an inductive graph: start with the empty graph (right hand side). Then, attach the first
context — the "Adj" values must be empty, because there are no nodes! Then, attach contexts one by one; each can only
refer to nodes that are already in the graph.</em></p>
<p>Each context must only refer to nodes which are already in the graph (or, to make loops work, itself).</p>
<p>In Python, operators resolve left-to-right, so to emulate this behaviour I've introduced a _<code>ContextPartial</code> class which
can collect up left-hand-side contexts until it reaches a graph, at which point it resolves. As a result, we can define
the <code>__and__</code> operator on the <code>Context</code> class like so:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Context</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Generic</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">match</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">Context</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">_ContextPartial</span><span class="p">((</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">case</span> <span class="n">InductiveGraph</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">NodeExistsError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;context </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> refers to existing node </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="si">}</span><span class="s2"> in graph </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">case</span> <span class="n">InductiveGraph</span><span class="p">()</span> <span class="k">if</span> <span class="n">disjoint_nodes</span> <span class="o">:=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">node</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">suc</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="ow">and</span> <span class="n">node</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">NodeDoesNotExistError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;context </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;refers to adjacent nodes </span><span class="si">{</span><span class="n">disjoint_nodes</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;which are not in graph </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">case</span> <span class="n">InductiveGraph</span><span class="p">()</span> <span class="o">|</span> <span class="n">EmptyGraph</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">InductiveGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</code></pre></div>

<p>This describes the behaviour when we do something like:</p>
<div class="codehilite"><pre><span></span><code><span class="n">context_a</span> <span class="o">&amp;</span> <span class="n">context_b</span> <span class="o">&amp;</span> <span class="n">EmptyGraph</span><span class="p">()</span>
</code></pre></div>

<p>When the context is added to an inductive graph where the node is already in the graph, or if the context's <code>Adj</code> nodes
refer to nodes that are <em>not</em> in the graph, we have to raise an error. Otherwise, regardless of whether it is an
inductive
graph or an empty graph, we can construct a new graph with the context as the head.</p>
<p>There are a couple of methods and properties here — <code>.nodes()</code>, <code>.pre</code>, <code>.suc</code> — which we haven't seen yet. More on
those in
the next part!</p>
<h1>Usage</h1>
<p>After these definitions, we're ready to follow the first example in the paper, Figure 1, which constructs a graph using
edges labeled "left", "right", "up", and "down", and nodes labeled "a", "b", and "c".</p>
<div class="codehilite"><pre><span></span><code><span class="p">([(</span><span class="s">&quot;left&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;up&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[(</span><span class="s">&quot;right&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)])</span><span class="w"> </span><span class="o">&amp;</span>
<span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[(</span><span class="s">&quot;down&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)])</span><span class="w"> </span><span class="o">&amp;</span>
<span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span>
<span class="kt">Empty</span>
</code></pre></div>

<p>becomes in Python:</p>
<div class="codehilite"><pre><span></span><code><span class="n">graph</span><span class="p">:</span> <span class="n">InductiveGraph</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">Context</span><span class="p">(</span>
            <span class="n">Adj</span><span class="p">(((</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="p">(</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">)))),</span>
            <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;a&quot;</span><span class="p">,</span>
            <span class="n">Adj</span><span class="p">(((</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">)),)),</span>
        <span class="p">)</span>
        <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Adj</span><span class="p">(((</span><span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">)),)))</span>
        <span class="o">&amp;</span> <span class="n">Context</span><span class="p">(</span><span class="n">Adj</span><span class="p">(),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">Adj</span><span class="p">())</span>
        <span class="o">&amp;</span> <span class="n">EmptyGraph</span><span class="p">()</span>
<span class="p">)</span>
</code></pre></div>

<p><img alt="A diagram reproducing the example in Erwig 2001, showing a directed graph with three nodes connected by four edges." src="example_graph.png" /></p>
<p><em>The node "a", with two predecessors and one successor, is attached to "b", with one successor, and then attached to "c",
with no predecessors or successors, and finally the empty graph.</em></p>
<h1>Next up</h1>
<p>In the next article, we'll work into the next parts of the paper, which describes the properties needed from the
inductive graph data types, and implement them in Python, and use them to implement some simple graph algorithms. Then,
in the final section, we'll tackle some more difficult algorithms like topological sorting. Thanks for keeping up with
me so far!</p>
<h1>References</h1>
<p>Erwig, Martin. "Inductive graphs and functional graph algorithms." Journal of Functional Programming 11.5 (2001):
467–492.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-07-09-build_day_5" href="#2021-07-09-build_day_5">Build Day 5</a>
          </span>
                
                    <span class="line"><small>2021-07-09</small></span>
                
            </h1>
            <p>So; after deciding that the full dinosaur family tree might be a little too ambitious for a showcase React project, I've brought myself back down to earth with something still challenging but manageable, and it's something I've wanted to tackle for a little while: an itenerary planner.</p>
<p>Here's the basic idea: when I go for a long trip, especially one overseas or involving multiple stops, I normally start to piece things together in a spreadsheet detailing the start, end, type of journey being made, and so on at each stage of the trip.
Often there are files or links associated with each stage that I'd also like to link, like PDFs of train tickets, Visas, or whatever.
However, there's often a lot of manual shuffling and rewriting for this kind of work - say I want to introduce an intermediate stop or two and I have to rearrange the origin and destination of the surrounding stops.
That's a pain and adds an element of tedium to the planning process.
It'd be nice to have a little app that did all that for me, without going into the complexities of apps like AirBnB or DesignMyNight or whatever that have a lot of connections going in (and out).
I just want to plan my trip, my way.</p>
<p>Now, in all honesty, it's unlikely that I can put something together here that will actually become <em>the</em> itinerary planner going forward.
There's a lot to be said for the flexibility of, say, a spreadsheet (or, it occurs to me, a Notion doc).
However, there are some really nice interactive components we can build here and as a project it's a pretty solid one, that I'm guessing visitors (hey, you!) can relate to, even if it's not something you (or I) are actually likely to use.</p>
<p>I'll probably next write when I've got a working prototype, because for now the whole thing is very much in the set-up phase.
Until then.</p>
<p>Note to self: build a table of contents for this page as well.
Perhaps even some smooth scrolling, idk.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-07-08-build_day_4" href="#2021-07-08-build_day_4">Build Day 4</a>
          </span>
                
                    <span class="line"><small>2021-07-08</small></span>
                
            </h1>
            <p>So; a couple of months later, a glass of wine in hand, with football apparently coming home, I'd like to reflect a little on why there has been such a long break between Build Days 3 and 4, and think a little bit more critically about some of the projects that I'd like to tackle going forward.</p>
<p>I'd started right away on the next project.
The plan was (seemed) quite simple.
I wanted a webapp - something to flex the old TypeScript muscles - which would be a searchable, interactive view of the whole Dinosaur family tree, starting with the earliest proto-dinosaurs and running through to the last species left alive when the meteorite hit.
I've always had an interest in dinosaurs (especially when younger - my mum once sent me in on a dress-up day as a paleontologist) and it seemed like a fun way to revisit some of that while having a go at a new build that I don't think has been attempted before.
How naïve I was.</p>
<p>Let me break down a couple of the challenges I faced.</p>
<h1>1. The Challenge of Trees</h1>
<p>I love me a tree structure.
I guess you could call me a linear algebraist by training (my PhD focused on things like <a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization">NMF</a> and data clustering) so graphs, nodes, and trees are something of a new language to me, but I've been using heirarchical structures for some frontend stuff at work and thinking about tree types in TypeScript got me really interested.
Feeling complacent (a family tree is just a tree, right?) I immediately charged down the route of encoding all the different taxonomic ranks (Genus, Class, Phylum and so on) as nodes in my future tree structure.</p>
<p>That idea fell apart pretty quickly, because as soon as I started looking at how to structure the actual <em>cladograms</em> (new bit of vocab for me there), I realised that many, if not most nodes didn't actually have a taxonomic rank ascribed to them.
Thinking back, that makes total sense.
The classification of a species clearly doesn't depend strictly on its actual evolution.
If that were true, then any given dinosaur species would simply have fewer entries in its classification tree than a modern animal.
The classification is actually <em>closer</em> to the vector/cluster description of a species than its family tree description.</p>
<p>Instead of simply grouping by phylum/class/order/family/genus/species, I'd have to take a much more sophisticated approach to encoding the family tree of each dinosaur.
No problem; more work, no doubt, and a less nicely-structured output (lots of nesting necessary) but doable.</p>
<p>I quickly ran into challenge 2.</p>
<h1>2. The Challenge of Actual Science™</h1>
<p>Although I'd anticipated challenges like the one above (it's a technical problem, after all, and creating good data structures is part of all coding) this next problem was not only the one that's slightly scuppered the project, but one I totally failed to see coming.</p>
<p>It turns out that - shockedpikachu.jpg - science isn't done.
In other words, there is <em>ongoing research</em> into the family trees of dinosaurs.
I know!</p>
<p>I'd decided to start small, work on the Lambeosauridae family first to nail down the interface and the data structures before working in the rest of the group.
It was going well - I'd marshalled a small set of species, arranged a tree for them, and was about ready to start coding up the frontend when I realised there was going to be a real logical problem.</p>
<p>What happens when scientists disagree about the tree?</p>
<p>Naively I thought I might be able to present a menu of options to the end user.
"Would you like Prieto-Marquez 2013 or 2015 [citation]?"
That by itself would be fine apart from the problem of tree-hopping species.
Depending on who you talk to, for instance, <a href="https://en.wikipedia.org/wiki/Arenysaurus">Arenysaurus</a> is either <em>deep</em> into the Lambeosaurini tribe <em>or</em> totally outside it!
Crazy!</p>
<p>Nightmare!</p>
<p>From a coding perspective this does actually pose some serious logical problems.
Let's say I've picked (higher up the tree) some cladogram proposed which shuffles around the Lambeosaurini tribe.
We then have no way of knowing which of the two proposed cladograms for Arenysaurus is compatible.
It's simply not possible to reconcile the trees.</p>
<h1>What's to be done?</h1>
<p>Now if I were going to be <em>really</em> sophisticated, I could take some of the algorithms that are used to <em>generate</em> the cladograms and expose <em>those</em> to the end-user.
That way, they could rearrange the whole tree at will in a nice interactive manner, and moreover perhaps explore some of the interesting differences between them.</p>
<p>That, however, is a much bigger project than I can take on (though the prospect of a second PhD <em>is</em> tempting).
For now, I'm going to have to let sleeping dinosaurs lie, and instead have a crack at something more manageable.</p>
<p>Until the next one, whenever that is.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-27-build_day_3" href="#2021-05-27-build_day_3">Build Day 3</a>
          </span>
                
                    <span class="line"><small>2021-05-27</small></span>
                
            </h1>
            <h1>commit</h1>
<p>Today we publish. The plan is to use GitHub pages, which at first glance seemed
pretty simple but none of the documentation immediately points to how to run
the repo through a build process before publication. So finding that out is
the immediate priority.</p>
<hr />
<p>Half an hour in and this is not nearly as easy as I expected. It seems these
custom builds just aren't really a part of the GitHub ecosystem and... I get
that... but I really think it ought to be achievable with GitHub actions.</p>
<h1>tag</h1>
<p>And another half an hour later and we're live at <a href="https://bm424.github.io/">bm424.github.io</a>!
Turned out to be not that difficult, just a heavy reliance on existing published
actions, which isn't something I'm very used to.</p>
<p>I'm going to write down what happened for my own future reference.</p>
<h2>Self-Tutorial</h2>
<p>There are three basic steps needed:</p>
<ol>
<li>Checkout your own repository. This is accomplished using the public
   "checkout" action, visitable <a href="https://github.com/actions/checkout">here</a>.
   This is surprising to me, as I'd have assumed this was more or less an
   automatic part of the process, but I suppose explicitly doing this is better
   than implicitly assuming it.</li>
<li>Create a version of your <em>own</em> build action. This was actually pretty
   simple, you can directly reference your own Docker image and the entire
   source repo is mounted in, so as long as you're using relative file names
   (normally a sad accident, but here a happy one) it pretty much successfully
   built first time, although I was a little confused about where the action
   was supposed to live (turns out top-level in the repo is fine).</li>
<li>Use yet another public image, this one sourced from a nice little tutorial
   <a href="https://www.pluralsight.com/guides/how-to-host-your-static-webpages-on-github-pages">here</a>,
   to push the site to your branch. A quick skim through the source code
   suggests this does much of the same manual stuff one might have implemented
   (git push to branch etc) but packaged up nice.</li>
</ol>
<p>Moving forward, I'm hoping I'll remember to refer to this repo as a canonical
example for myself.</p>
<p>Until next time.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-26-build_day_2" href="#2021-05-26-build_day_2">Build Day 2</a>
          </span>
                
                    <span class="line"><small>2021-05-26</small></span>
                
            </h1>
            <h1>print()</h1>
<p>So, main changes today include adding support for each posts's metadata,
handling multiple posts building to the same page in the correct order,
and some small updates to improve the site's aesthetics including some
page hierarchy and correct scaling on mobile.</p>
<p>One of the things I find it's really important to do, particularly in personal
projects, is write a few notes to yourself to remind you simply what commands
to write to get things working again. It sounds obvious, but a lot of the actual
minutes spent on a programming project for me are spent working out the correct
order of operations.</p>
<p>For this project, the relevant command is a simple</p>
<div class="codehilite"><pre><span></span><code>docker-compose build &amp;&amp; docker-compose run main
</code></pre></div>

<p>but in a web project with multiple moving parts these kinds of crucial lines
can be easy to forget or get lost in a maze of possible, often redundant (in
the sense of overlapping functionality) scripts. So when I write a README file,
it's as much for me as for anyone else who might pick up the project.</p>
<h1>.split()</h1>
<p>One thing that came up while coding today was the issue of post permalinks.
I'm not even going to <em>attempt</em> to go there. The quick solution I settled on
was to link to the posts using the file name. As I anticipate I'll be changing
those much less than the titles of the posts, they ought to be permanent enough,
and they map to the titles sufficiently closely to be sensible in the URL.</p>
<p>Come to think of it, this may be similar to what professional static site
generators do, given the mismatch between URLs and post titles that I sometimes
see.</p>
<p>On an unrelated note, using a NamedTuple was a good way to pass values into
the Jinja templates quickly, but it's quickly showing its limitations. I've
been using Pydantic a lot at work and I like it a lot, we'll see if I need to
get it involved here, depending on how much the complexity of the NamedTuple
structure increases.</p>
<h1>:focus</h1>
<p>To wrap up, I spent a fair bit of time faffing around with the style of the
anchor links to the posts. This is actually the kind of thing I tend to find
really fun, because webpage style is one of the ways it's easy to get a little
creative in projects like this. That said, I often get carried away in style
over substance. Part of this project is to focus on getting the content out,
rather than perfecting style, so with these final changes I'm going to call
it a day and implement the GitHub pages build another time.</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-23-build_day_1" href="#2021-05-23-build_day_1">Build Day 1</a>
          </span>
                
                    <span class="line"><small>2021-05-23</small></span>
                
            </h1>
            <h1>import</h1>
<p>A couple of hours later and we have a working static site builder running
locally using Docker, Python, Jinja2, markdown, and not much else. On the
whole I'm pretty happy with the timing, particularly considering a fairly
significant chunk of that was actually writing the build day 0 content.</p>
<p>I initially thought I'd be needing a running server to see changes live, but
quickly realised that was going to be unnecessary - the Docker rebuild was
more than quick enough to get a fast feedback loop going, and the most
fiddly bit, the CSS, I could actually just do in the build styles, refreshing
the page in the meantime, then copy back into the source when done.</p>
<h1>next()</h1>
<p>Simple enough so far. However, having now added this next file, I need to make
a couple of changes to ensure one can navigate to past entries, and then it
should be a simple case of deploying to GitHub pages.</p>
<p>I say that. I've done it before, but quite a long time ago (my company uses
GitLab, so I'm a little out of practice)... so see you in the next entry.</p>
<h1>wraps()</h1>
<p>I've slightly backdated this post because these reflections were based on the
hour or two of work I did after writing the first day's post a couple of days
ago, and I want to spend a bit of time after today (2021-05-26) reflecting
on today's work instead. Just for transparency's sake...</p>
        </article>
    
        <article>
            <h1 class="post-title">
          <span class="line">
            <a id="2021-05-23-build_day_0" href="#2021-05-23-build_day_0">Build Day 0</a>
          </span>
                
                    <span class="line"><small>2021-05-23</small></span>
                
            </h1>
            <h1>def</h1>
<p>All projects begin somewhere, and this is where this one begins.</p>
<p>Over the next few weeks and months, I'll be building a personal
portfolio/showcase of code projects, each chosen for both personal interest
and to demonstrate my use of particular technologies, such as the web stack,
machine learning, or programming interface development.</p>
<h1>__doc__</h1>
<p>Why?</p>
<p>Well, firstly, a lot of the code I write is for the company I work for,
and so while the things I can do has expanded significantly over the last few
years, none of it is particularly reflected in my GitHub profile, and I'd like
to bring that up to date.</p>
<p>Secondly, I want to create a coding space for myself that is less restricted
by deadlines and "product" pressure, to try and focus on best practices,
and to exercise older programming skills I used to use regularly (such as
in training neural networks).</p>
<p>And lastly, I think the projects I've lined up are going to be a lot of fun,
and by tackling some of them I hope I can rekindle my enthusiasm for hobbyist
programming.</p>
<h1>__call__</h1>
<p>So what are these projects to be? In order of increasing complexity:</p>
<ol>
<li>This! A simple static site generator, from scratch, written in Python and
   markdown, where I can record my progress and thoughts on each project
   as I go.</li>
<li>A bit of a personal exercise, writing a simple Schrödinger equation
   solver in Python, with graphical output. If it goes well, I'll convert
   it into a web app.</li>
<li>A dinosaur family tree/cladogram, implemented as a web app using React
   and/or Redux, interactive, searchable, and live on the web.</li>
<li>A board game, called Bao, which I learned as a kid on holiday in Zanzibar,
   implemented in Rust using Bevy.</li>
<li>An open street map tile neural network tile generator, implemented in
   Python and, if all goes well, deployed as a web app.</li>
</ol>
<h1>__exit__</h1>
<p>This particular post was written before any code, and represents simply
the starting point for project 1. Next post, I'll be writing up reflections
on the implementation of this little custom static site generator. If you've
read this far, thanks! And see you next time.</p>
        </article>
    
</main>
<footer>
    <nav>
        <ol>
            
                <li><a href="#2023-01-02-functional_graph_algorithms_3">2023-01-02</a></li>
            
                <li><a href="#2022-12-26-functional_graph_algorithms_2">2022-12-26</a></li>
            
                <li><a href="#2022-12-19-functional_graph_algorithms_1">2022-12-19</a></li>
            
                <li><a href="#2021-07-09-build_day_5">2021-07-09</a></li>
            
                <li><a href="#2021-07-08-build_day_4">2021-07-08</a></li>
            
                <li><a href="#2021-05-27-build_day_3">2021-05-27</a></li>
            
                <li><a href="#2021-05-26-build_day_2">2021-05-26</a></li>
            
                <li><a href="#2021-05-23-build_day_1">2021-05-23</a></li>
            
                <li><a href="#2021-05-23-build_day_0">2021-05-23</a></li>
            
        </ol>
    </nav>
</footer>
</body>
</html>